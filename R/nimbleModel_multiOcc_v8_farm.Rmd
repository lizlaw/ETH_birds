---
title: "bayesBirdModel_multiSPecies_v8 - FARM"
author: "Liz Law"
date: "4 Apr 2022"
output: html_document
---
workingconservation@gmail.com

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Updates from v7:

* remove known info on z
* provide all uniform priors, logit mulpsi
* betalP not species specific
* rare species no longer share params

# Setup
```{r library setup}
library(nimble)
library(tidyverse)

wd <- "/Users/elaw/Desktop/LeuphanaProject/BirdModelling/ETH_birds"
data_input <- paste0(wd, "/Data/nimbleModel_multiOcc_v6_allData.RDS")
results_folder <- paste0(wd, "/Results/")  
version_folder <- "v8/"

```

# build model
```{r model code}
occupancy_code <- nimbleCode({
  
  # Priors
  
    # Proportion of species present in the study region assuming nSpecies > nObsSpecies
    # omega ~ dunif(0,1)  
    
    # Hyperpriors describe the community
  
    # For the model of occupancy (psi)
    Mu.lpsi ~ dunif(0,1) # dnorm(0,0.01)
    mu.lpsi <- logit(Mu.lpsi)
    sd.lpsi ~ dunif(0, 12)   # bounds of uniform chosen by trial and error
    
    for (lpsii in 1:npsi){
      mu.betalpsi[lpsii] ~ dunif(-5, 5) #dnorm(0, 2.25)   # recommended default priors
      #sd.betalpsi[lpsii]  ~ dunif(0, 6)
    }
    sd.betalpsi  ~ dunif(0, 6) # constant sd for all psi params

    # For the model of detection (p)
    Mu.lp ~ dunif(0,1) # dnorm(0,0.01)
    mu.lp <- logit(Mu.lp)
    sd.lp ~ dunif(0, 5) # bounds of uniform chosen by trial and error
    
    #for (lpi in 1:np){
      # mu.betalp[lpi] ~ dunif(-5, 5) #dnorm(0, 2.25)
      # sd.betalp[lpi] ~ dunif(0, 5)
    #}
    mu.betalp ~ dunif(-5, 5)# constant mu for all p params
    sd.betalp ~ dunif(0, 5) # constant sd for all p params
    
    # Priors for species-specific effects in occupancy and detection
    # are derived from the community level distributions
    for(k in 1:M){   
      # occupancy
      lpsi[k] ~ dnorm(mu.lpsi, sd=sd.lpsi)    
      for (lpsii in 1:npsi){
         betalpsi[k, lpsii] ~ dnorm(mu.betalpsi[lpsii], sd=sd.betalpsi)# [lpsii])
      }
      
      # detection
      lp[k] ~ dnorm(mu.lp, sd=sd.lp)
      #for(lpi in 1:np){
      #  betalp[k, lpi] ~ dnorm(mu.betalp, sd=sd.betalp) #[lpi])
      #}
    }
     for(lpi in 1:np){
        betalp[lpi] ~ dnorm(mu.betalp, sd=sd.betalp) #[lpi])
      }
    
    # Super-population process: proportion of species in the regional pool part of the community 
    #for(k in 1:M){
    #  w[k] ~ dbern(omega)  # w is binary presence of each species in the community
    #}
    
    # Ecological model for true occurrence (process model) - enviro variables
    for(k in 1:M){
      for (i in 1:nSite) {
        logit(psi[i,k]) <- lpsi[k] + 
           betalpsi[k,1] * Xoc[i,1] +  # elevation
           betalpsi[k,2] * Xoc[i,2] +  # fl_dis
           betalpsi[k,3] * Xoc[i,3]    # sidi1ha
          # betalpsi[k,4] * Xoc[i,4]   # slope 
          # betalpsi[k,5] * Xoc[i,5]   # farm_type !Binary
        mu.psi[i,k] <- psi[i,k] # * w[k]
        z[i,k] ~ dbern(mu.psi[i,k])
      }
    }
    
    # Observation model for replicated detection/non-detection observations 
    for(k in 1:M){
      for (i in 1:nSite){
        for(j in 1:nVisits){
          logit(p[i,j,k]) <- lp[k] + 
            betalp[1] * Xob[i,j,1] + # date
            betalp[2] * Xob[i,j,2] + # start1
            betalp[3] * Xob[i,j,3] #+ # start2
            # betalp[4] * Xob[i,j,4]   # visibility !Binary
          mu.p[i,j,k] <- z[i,k] * p[i,j,k]   
          Y[i,j,k] ~ dbern(mu.p[i,j,k])  
        }
      }
    }
    
    # Derived quantities
    for (i in 1:nSite){
      SR_site_all[i] <- sum(z[i,1:M])          # Number of occurring species at each site
      SR_site_obs[i] <- sum(z[i,1:Nobs])       # Number of observed species occurring species at each site
      SR_site_fspp[i] <- sum(z[i,1:Nobs] * fspp[1:Nobs])        # forest dependent species
      SR_site_mig[i] <- sum(z[i,1:Nobs] * mig[1:Nobs])          # migrants
      SR_site_fnDiet[i] <- sum(z[i,1:Nobs] * fnDiet[1:Nobs])    # fruit/nectar species
      SR_site_invDiet[i] <- sum(z[i,1:Nobs] * invDiet[1:Nobs])  # invertebrate species
    }
    #n0 <- sum(w[(Nobs+1):M])              # Number of unseen species over study
    #Ntotal <- sum(w[1:M])                 # Total metacommunity size
    
})
```

# Specify model: code, data (observed), constants (set), and inits (starting value for estimated values)

```{r import data}
nimData <- readRDS(data_input)

y_all <- nimData$y_all
farmSites <- nimData$farmSites
OccVarsFarm <- nimData$OccVarsFarm
ObsVarsFarm <- nimData$ObsVarsFarm
sppTraits <- nimData$sppTraits
Nadd <- 17 # based on individual rarefaction curves

y <- y_all[(dimnames(y_all)[[1]] %in% farmSites), , ]       # [site, visit, species]

nSite <- dim(y)[1]
nVisits <- dim(y)[2]
Nobs <- dim(y)[3]
M <- Nobs + Nadd
Y <- abind::abind(y, array(0, dim = c(dim(y)[1:2], Nadd)))  ## add the 'missing' species - not seen so = 0, 'absence'

# inits: if we observe them in a survey they are there
# z <- array(apply(Y, c(1,3), sum, na.rm = TRUE), dim=dim(Y)[c(1,3)]); z[] <- ifelse(z > 0, 1, NA) 
# w <- c(rep(1, Nobs), rep(NA, Nadd)) 

Xoc <- OccVarsFarm %>% select(-point_id) %>% as.matrix() %>% array(dim = dim(.))   # [site, vars]
Xob <- array(NA, dim = c(nSite, nVisits, dim(ObsVarsFarm)[2]-2)) # [site, visit, vars]
Xob[,,1] <- ObsVarsFarm %>% arrange(round, point_id) %>% pull(date)
Xob[,,2] <- ObsVarsFarm %>% arrange(round, point_id) %>% pull(start1)
Xob[,,3] <- ObsVarsFarm %>% arrange(round, point_id) %>% pull(start2)
Xob[,,4] <- ObsVarsFarm %>% arrange(round, point_id) %>% pull(visibility)

# constrain to best functioning variables
Xoc <- Xoc[,1:3]
Xob <- Xob[,,1:3]

npsi <- dim(Xoc)[2]
np <- dim(Xob)[3]

# groups of interest
fspp <- sppTraits$forSpec 
mig <- sppTraits$migYes 
fnDiet <- sppTraits$FruiNect 
invDiet <- sppTraits$Invertebrate 

# common/rare vector numbers
rareSpp <- min(which(sppTraits$sumObs1))
commonSpp <- rareSpp-1

data <- list(Y = Y, 
             # v = v,
             # z = z,
             #w = w,
             Xoc = Xoc,
             Xob = Xob)  
constants <- list(nSite = nSite, 
                  nVisits = nVisits, 
                  Nobs = Nobs,
                  Nadd =  Nadd, 
                  M = M,
                  npsi = npsi,
                  np = np,
                  rareSpp=rareSpp,
                  commonSpp=commonSpp,
                  fspp=fspp,
                  mig=mig,
                  fnDiet=fnDiet,
                  invDiet=invDiet)

# Initial values - match up with the number of observed vars used in the model
#omega <- Nobs/M
#wst <- rep(1, M)                   # Simply set everybody at occurring
zst <- array(1, dim = c(nSite, M)) # ditto
lpsi <- rnorm(n = M)
betalpsi <- array(rnorm(n = M * npsi), dim = c(M, npsi))
lp <- rnorm(n = M)
# betalp <- array(rnorm(n = M * np), dim = c(M, np))
betalp <- rnorm(n =  np)

inits <- list(
  #omega = omega,
  z = zst, 
  #w = wst, 
  lpsi = lpsi, 
  betalpsi = betalpsi, 
  lp = rnorm(n = M), 
  betalp = betalp #,
  #Yb = Y
)

# Set 1
params1 <- c("mu.lpsi", "sd.lpsi", "mu.betalpsi", "sd.betalpsi", 
             "mu.lp", "sd.lp", "mu.betalp", "sd.betalp", 
             "SR_site_all", "SR_site_obs",
             "SR_site_fspp", "SR_site_mig","SR_site_fnDiet", "SR_site_invDiet") #,
             # "omega", "n0", "Ntotal")


```

## the short, default way
```{r run nimbleMCMC}

# MCMC settings - development - final
# (ni - nb)/nt # samples per chain
# ni <- 10      ;   nt <- 1    ;   nb <- 0       ;   nc <- 3
 ni <- 25000   ;   nt <- 10   ;   nb <- 0   ;   nc <- 3
# ni <- 50000   ;   nt <- 20   ;   nb <- 0   ;   nc <- 3
# ni <- 50000   ;   nt <- 20   ;   nb <- 15000   ;   nc <- 3
# ni <- 130000  ;   nt <- 30   ;   nb <- 25000   ;   nc <- 3   # = 3500 samples per chain

samples <- nimbleMCMC(
  code = occupancy_code,
  data = data,
  constants = constants,
  inits = inits,
  monitors = params1,
  thin = nt,
  niter = ni,
  nburnin = nb,
  nchains = nc)
```

## Or the long way
```{r not run manually compile build run}
# # Build the model
# occupancy_model <- nimbleModel(
#  occupancy_code,
#  data = data,
#  constants = constants,
#  inits = inits
# )
# 
# # configure the MCMC algorithm and build the MCMC object using default samplers
# MCMCconf <- configureMCMC(occupancy_model, monitors = params1)

# check samplers
# MCMCconf$printSamplers()

# we may want to change the samplers - testing automated blocking 
# https://r-nimble.org/html_manual/cha-mcmc.html#automated-parameter-blocking
# autoBlockConf <- configureMCMC(occupancy_model, monitors = params1, autoBlock = TRUE)
# 
# MCMC <- buildMCMC(autoBlockConf, monitors = params1, thin = nt)
# # 
# # # compile for faster execution
# CMCMC <- compileNimble(MCMC, project = occupancy_model)
# # 
# # ## Run the MCMC and extract the samples
# samples <- runMCMC(mcmc = CMCMC, niter = ni, nburnin = nb, nchains = nc)
```

```{r save results}
saveRDS(samples, paste0(results_folder, version_folder, "BirdOccMod_samples_farm_", format(Sys.time(), "%Y%m%d"), ".RDS"))
```
 
# model diagnostics
 
```{r MCMCvis}

library(MCMCvis)

pg1 <- c("SR_site_all") #"omega", "n0", "Ntotal", 
pg2 <-c("mu.lpsi", "sd.lpsi", "mu.betalpsi", "sd.betalpsi", "mu.lp", "sd.lp", "mu.betalp", "sd.betalp")

# summary of estimates
mySum1 <- MCMCsummary(samples, 
            params = pg1, 
            round = 2)

mySum2 <- MCMCsummary(samples, 
            params = pg2, 
            round = 2)

# trace plots
MCMCtrace(samples, 
          params = pg1,
          ind = TRUE, 
          Rhat = TRUE, n.eff = TRUE,
          filename = paste0("Results/", version_folder, "plots_traceDensity_pg1_farm_", format(Sys.time(), "%Y%m%d"), ".pdf"))
MCMCtrace(samples, 
          params = pg2,
          ind = TRUE, 
          Rhat = TRUE, n.eff = TRUE,
          filename = paste0("Results/", version_folder, "plots_traceDensity_pg2_farm_", format(Sys.time(), "%Y%m%d"), ".pdf"))

# caterpillar plots
MCMCplot(samples, 
         # samples for model 2,
         params = pg2, 
         ci = c(50, 90), 
         HPD = FALSE)  # plots equal tailed credible intervals

MCMCplot(samples, 
         # samples for model 2,
         params = 'SR_site_all', 
         ci = c(50, 90), 
         HPD = FALSE)  # plots equal tailed credible intervals
```

